<!--

	Text v0.0.1

	created and maintained by https://ihasq.com

	editor style settings are modifiable at /html/body/style

	original coding style "vent code"

-->

<!DOCTYPE html>

<html>

	<head>

		<title>Text (unsaved)</title>

		<meta charset="utf-8"/>

		<style>

			* {
				box-sizing: border-box;
			}

			.grid {
				display: grid;
			}


			html {
				height: 100vh;
				width: 100vw;
			}

			body, div#wrapper, #editorGrid {
				height: 100%;
				width: 100%;
			}

			html, body, div#wrapper, #editorGrid, #editorLine {
				padding: 0px;
				margin: 0px;
				user-select: none;
			}

			body {
				grid-template-rows: auto calc(var(--editor-font-size) + 4px);
			}

			div#wrapper {
				position: relative;
			}

			#editorGrid, #commandline, #scrollTopBar, textarea#input {
				position: absolute;
			}

			#editorGrid {
				z-index: 0;
				grid-template-columns: var(--editor-lineNumber-width) auto;
				width: 100%;
				height: 100%;
				overflow: hidden;
			}

			#editorLine {
				font-family: var(--editor-font-family);
				font-size: var(--editor-font-size);
				tab-size: var(--editor-tab-size);
				line-height: var(--editor-line-height);

				color: var(--editor-line-color);
				background-color: var(--editor-line-background-color);

				margin: 0px;
				padding: 6px;
			}

			#editor {
				font-family: var(--editor-font-family);
				font-size: var(--editor-font-size);
				tab-size: var(--editor-tab-size);
				line-height: var(--editor-line-height);

				background-color: var(--editor-background-color);
				color: var(--editor-color);

				overflow: hidden;

				height: max-content;
				min-height: 100%;

				margin: 0px;
				padding: 6px;

				cursor: text;

				user-select: auto;
			}

			#editor:focus {
				outline: var(--editor-focus-outline);
			}

			#commandline {
				z-index: 2;
				top: 10px;
				left: 30%;
				right: 30%;
				width: 40%;
				
				border-radius: 3px;
			}

			#scrollTopBar {
				z-index: 1;
				right: 0;
				width: 4px;
				height: 50%;
				background-color: #555;
				opacity: 70%;
				border-radius: 2px;
			}

			span#caret[blink="on"] {
				outline: var(--editor-caret-style);
			}

			span#caret[blink="off"] {
				outline: none;
			}

			textarea#input {
				z-index: -1;
				height: 8px;
				width: 8px;
				opacity: 0;
				resize: none;
				user-select: none;
			}

			div#footer {
				background-color: #292929;
				font-family: var(--editor-font-family);
				color: var(--editor-color);
				font-size: calc(var(--editor-font-size) * 0.95);
				outline-offset: -0.5px;
				width: 100%;
				grid-template-columns: 100px auto 200px;
				overflow: hidden;
			}
			div#footer > div {
				margin: auto 0;
			}
			div#footer > div > span {
				margin-left: 10px;
			}
		</style>

	</head>

	<body class="grid">

		<!-- editor style -->

		<style id="settings">

			* {
				--editor-font-family:				"Consolas", 'Courier New', "Courier", "Monaco", "monospace";
				--editor-font-size:					14px;
				--editor-tab-size:					4;
				--editor-line-height: 				16px;

				--editor-color:						#fff;
				--editor-background-color:			#222;

				--editor-line-background-color:		#333;
				--editor-line-color:				#dde;

				--editor-caret-style:				1px solid #fff;

				--editor-focus-outline:				none;

				--editor-lineNumber-width:			40px;

				--editor-scrollBar-activeWidth:		16px;
				--editor-scrollBar-minimalWidth:	4px;

				--file-autosave-delaytime:			1000ms
			}

			#commandline {
				font-family: Consolas, 'Courier New', Courier, Monaco, monospace;
				font-size: 14px;

				height: 26px;

				border: none;

				padding: 7px;

				background-color: #111;

				color: #fff;

				box-shadow: 0 5px 25px 0 rgba(0, 0, 0, .5);

				outline: 1px solid #ccd;
			}

		</style>


		<div id="wrapper">

			<div class="grid" id="editorGrid">

				<pre id="editorLine"></pre>

				<pre id="editor"><span class="lineWrapper active"><span id="caret" blink="on"></span> </span></pre>

			</div>

			<div id="scrollTopBar"></div>

			<input id="commandline" title="type 'help' for more info"/>

			<textarea id="input"></textarea>

		</div>

		<div class="grid" id="footer">
			<div>abc</div>
			<div></div>
			<div><span>タブ: 4</span><span>HTML</span></div>
		</div>


		<script type="text/javascript">

			"use strict";

			{
				window.editor = {

					mode: "insertion",

					element: {

						surface: document.getElementById("editor"),
						commandline: document.getElementById("commandline"),
						editorGrid: document.getElementById("editorGrid"),
						editorLine: document.getElementById("editorLine"),
						input: document.getElementById("input"),
						editorCaret: document.getElementById("caret")

					},

					editor: {

						lines: 0,
						focusLine: 1,
						lastKeyDownedTimestamp: -1,
						currentBufferId: -1,
						minimalEditorLineDigits: 3,

						refresh() {
							setTimeout(() => {
								globalThis.editor.buffer.textData = globalThis.editor.element.input.value;
								let temp = {
									matchedLine: globalThis.editor.buffer.textData.split("\n").length,
									lineDOM: "",
								}

								if(!(globalThis.editor.editorProperty.editorLine == temp.matchedLine)) {
									temp.lineDigits = temp.matchedLine.toString().length;
									if(temp.lineDigits < globalThis.editor.editorProperty.minimalEditorLineDigits) temp.lineDigits = globalThis.editor.editorProperty.minimalEditorLineDigits;

									for(let i = 1; i <= temp.matchedLine; i++) temp.lineDOM += ( " ".repeat(temp.lineDigits - i.toString().length) + i + "\n" );

									globalThis.editor.element.editorLine.textContent = (temp.lineDOM += "\n".repeat(Math.ceil(document.documentElement.clientHeight / 14) - 2));
									globalThis.editor.editorProperty.editorLine = temp.matchedLine;
								}

								document.getElementById("input").focus();

							}, 0);
						}
					},

					buffer: {

						fileName: "",
						fileHandle: null,

						currentControlQueue: [],
						textData: "",

						open: async (readAs) => {

							let temp = Object.create(null);

							[this.fileHandle] = await window.showOpenFilePicker(

								{
									types: [
										{
											description: "Text file",
											accept: {
												"text/*": [],
												"application/*": []
											},
										}
									],
									excludeAcceptAllOption: true,
									multiple: false
								}

							);

							temp.result = new FileReader;
							temp.result.readAsText(await this.fileHandle.getFile(), (readAs || "UTF-8"));

							temp.result.onload = event => {
								document.getElementById("input").value = event.target.result;
								globalThis.editor.action.refresh();
							}

						},

						save: async () => {

							let temp = Object.create(null);

							if(!this.fileHandle) this.fileHandle = await window.showSaveFilePicker({
								types: [
									{
										description: "Text file",
										accept: {
											"text/*": []
										}
									},
								]
							});

							temp.writable = await this.fileHandle.createWritable();
							await temp.writable.write(this.textData);
							await temp.writable.close();

						},

						flush() {
							this.fileHandle = null;
							document.getElementById("input").value = "";

							globalThis.editor.action.refresh();
						},

						undo() {},

						redo() {},
					},

					command: {

						arg: [],

						query: {
							"save"() {
								globalThis.editor.buffer.save();
							},

							"open"() {
								globalThis.editor.buffer.open();
							},

							"new"() {
								globalThis.editor.buffer.flush();
							},

							"about"() {
								window.open("./about.html", { target: "_blank" });
							},

							"alert"() {
								alert(globalThis.editor.command.arg.join(" "));
							},

							"showinput"() {
								console.log(document.getElementById("input"));
							},

							">"() {
								this.query[this.arg[1]]();
							}
						},

						history: [],
						historyIndex: 0,

						exec(args) {

						}

					},

					editorProperty: {

						editorLine: 0,
						focusLine: 1,
						lastKeyDownedTimestamp: -1,
						currentBufferId: -1,
						minimalEditorLineDigits: 3

					},

					keyProperty: {

						ctrl: false,
						shift: false,
						alt: false

					},

					selectionProperty: null,

					action: {

						refresh() {

							setTimeout(() => {

								globalThis.editor.buffer.textData = globalThis.editor.element.input.value;

								let temp = {

									matchedLine: globalThis.editor.buffer.textData.split("\n").length,
									lineDOM: "",
								}

								if(!(globalThis.editor.editorProperty.editorLine == temp.matchedLine)) {

									temp.lineDigits = temp.matchedLine.toString().length;
									if(temp.lineDigits < globalThis.editor.editorProperty.minimalEditorLineDigits) temp.lineDigits = globalThis.editor.editorProperty.minimalEditorLineDigits;

									for(let i = 1; i <= temp.matchedLine; i++) temp.lineDOM += ( " ".repeat(temp.lineDigits - i.toString().length) + i + "\n" );

									globalThis.editor.element.editorLine.textContent = (temp.lineDOM += "\n".repeat(Math.ceil(document.documentElement.clientHeight / 16) - 2));
									globalThis.editor.editorProperty.editorLine = temp.matchedLine;

								}

							}, 0);
						},

						cmd(arg) {
							if(typeof arg === "string") {
								globalThis.editor.command.arg = arg.split(" ");
								globalThis.editor.command.history.unshift(globalThis.editor.command.arg);
								globalThis.editor.command.query[globalThis.editor.command.arg[0]]();
							}
						},
					},
				}

				window.onload = () => {

					editor.element.commandline.style.visibility = "hidden";

					[
						[ () => document.getElementById('caret').setAttribute('blink', (document.getElementById('caret').getAttribute('blink') == 'on')? 'off' : 'on'), 600 ],

					].forEach(set => setInterval(...set));

					[
						[
							"beforeunload", event => {

								event.preventDefault();
								event.returnValue = "";

							}, { passive: false }
						],

						[
							"wheel", event => {

								event.preventDefault();
							
								let temp = Object.create(null);
								temp.isShiftUnpressed = !globalThis.editor.keyProperty.shift;
								temp.top = (temp.isShiftUnpressed)? "deltaY" : "deltaX";
								temp.left = (temp.isShiftUnpressed)? "deltaX" : "deltaY";

								editor.element.editorGrid.scrollTop += event[temp.top];
								editor.element.surface.scrollLeft += event[temp.left];

							}, { passive: false }
						],

						[
							"keydown", event => {

								switch(event.code) {

									case "F1":

										event.preventDefault();
										editor.mode = "command";
										editor.element.commandline.style.visibility = "visible";
										editor.element.commandline.value = "> "
										editor.element.commandline.focus();

									break;
								}

								switch(event.target.id) {

									case "input":

										switch(event.code) {
											case "Tab":

											break;
										}

										editor.action.refresh();

									break;

									case "editor":

										editor.keyProperty.ctrl = event.ctrlKey;
										editor.keyProperty.shift = event.shiftKey;
										editor.keyProperty.alt = event.altKey;

										if(editor.keyProperty.ctrl) {

											switch(event.code) {

												case "KeyZ":

													event.preventDefault();

												break;
											}

										} else {
										
											switch(event.code) {
											
												case "Tab":

													event.preventDefault();

												break;

												case "Backspace":

													if(editor.element.surface.textContent.length == 1) {

														event.preventDefault();

													} else {

														editor.action.refresh();

													}

												break;
											}
										}

									break;

									case "commandline":

										switch(event.code) {

											case "Enter":

												event.preventDefault();
												editor.action.cmd(editor.element.commandline.value);
												editor.element.commandline.value = "";

											break;

											case "Escape":

												event.preventDefault();
												document.activeElement.blur();
												editor.element.commandline.style.visibility = "hidden";
												editor.element.input.focus();

											break;
										}

									break;
								}

							}, { passive: false }
						],

						[
							"keyup", event => {

								switch(event.target.id) {

									case "editor":
										editor.keyProperty.ctrl = event.ctrlKey;
										editor.keyProperty.shift = event.shiftKey;
										editor.keyProperty.alt = event.altKey;
										
									break;
								}

							}, { passive: true }
						],

						[
							"mouseup", event => {

								switch(event.target.id) {

									case "editor":

										event.preventDefault();
										document.activeElement.blur();
										editor.element.commandline.style.visibility = "hidden";
										editor.element.input.focus();

									break;

								}

							}
						]

					].forEach(index => window.addEventListener(...index));

					for(const instance in editor.timeoutProcess) editor.timeoutProcess[instance]();

					editor.action.refresh();

					document.getElementById("input").focus()

				}
			}

		</script>

	</body>

</html>