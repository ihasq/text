<!--

	Text v0.0.1

	created and maintained by https://ihasq.com

	editor style settings are modifiable at /html/body/style

-->

<!DOCTYPE html>

<html>

	<head>

		<title>Text (unsaved)</title>

		<meta charset="utf-8"/>

		<style>

			* {
				box-sizing: border-box;
			}

			.grid {
				display: grid;
			}


			html {
				height: 100vh;
				width: 100vw;
			}

			html, body {
				overflow: hidden;
			}

			body, div#wrapper, #editorGrid {
				height: 100%;
				width: 100%;
			}

			html, body, div#wrapper, #editorGrid, #editorLine {
				padding: 0px;
				margin: 0px;
				user-select: none;
			}

			body {
				grid-template-rows: auto calc(var(--editor-font-size) + 8px);
			}

			div#wrapper {
				position: relative;
			}

			div#wrapper > * {
				position: absolute;
			}

			#editorGrid {
				z-index: 0;
				grid-template-columns: var(--editor-lineNumber-width) auto;
				width: 100%;
				height: 100%;
				overflow: hidden;
			}

			#editorLine {
				font-family: var(--editor-font-family);
				font-size: var(--editor-font-size);
				tab-size: var(--editor-tab-size);
				line-height: var(--editor-line-height);

				color: var(--editor-line-color-inactive);
				background-color: var(--editor-line-background-color);

				border-right: 1px solid #363636;

				margin: 0px;
				padding: 6px 3px;
			}

			#editorSurface {
				font-family: var(--editor-font-family);
				font-size: var(--editor-font-size);
				tab-size: var(--editor-tab-size);
				line-height: var(--editor-line-height);

				background-color: var(--editor-background-color);
				color: var(--editor-color);

				overflow: hidden;

				height: max-content;
				min-height: 100%;

				margin: 0px;
				padding: 6px 10px 0px;

				cursor: text;

				user-select: auto;
			}

			#editorSurface:focus {
				outline: var(--editor-focus-outline);
			}

			#scrollTopBar {
				z-index: 2;
				right: 0;
				width: 4px;
				height: 50%;
				background-color: #555;
				opacity: 70%;
				border-radius: 2px;
			}

			#editorSurface::after {
				content: " ";
			}

			span#caret[blink="on"] {
				outline: var(--editor-caret-style);
			}

			span#caret[blink="off"] {
				outline: none;
			}

			textarea#input {
				z-index: 1;
				opacity: 0;
				height: 4px;
				width: 1px;
				resize: none;
				user-select: none;
				border: none;
				padding: 0px;
			}

			#footer {
				background-color: #212224;
				color: var(--editor-footer-color);

				font-family: var(--editor-font-family);
				font-size: calc(var(--editor-font-size) * 0.9);

				border-top: 1px solid #363636;

				width: 100%;
				grid-template-columns: 200px auto 400px;
				overflow: hidden;
			}

			#footer > div {
				width: auto;
				margin: auto 6px;
			}

			#footer > div.left > span {
				margin-left: 4px;
			}

			#footer > div.right {
				text-align: end;
			}

			#footer > div.right > span {
				text-align: end;
				margin-right: 4px;
			}

			#editorLine > span.active {
				color: var(--editor-line-color);
			}

			#contextmenu {
				width: 220px;
				height: max-content;
				background-color: #242429;
				outline: 1px solid #555;
				border-radius: 3px;
				overflow: hidden;
			}

			#contextmenu[state="active"] {
				z-index: 3;
			}

			#contextmenu[state="hidden"] {
				z-index: -1;
			}

			#contextmenu > div.group {
				border-bottom: 1px solid #555;
			}

			#contextmenu > div.group:last-child {
				border-bottom: none;
			}

			#contextmenu > div.group > div.index {
				grid-template-columns: auto 60px;
				font-size: 13px;
				font-family: var(--editor-font-family);
				color: #bbb;
				padding: 5px 18px;
				background-color: transparent;
			}

			#contextmenu > div.group > div.index.disabled {
				color: #666;
			}

			#contextmenu > div.group > div.index > span:last-child {
				color: #999;
				text-align: end;
				font-size: calc(var(--editor-font-size) * 0.8);
			}

			#contextmenu > div.group > div.index:hover:not(.disabled) {
				background-color: #363636;
				color: #fff;
			}

			#contextmenu > div.group > div.index:first-child {
				padding-top: 7px;
			}

			#message {
				height: max-content;
				width: max-content;
				inset: calc(100% - 48px) 16px 0 auto;
				background-color: #222;
				outline: 1px solid #555;
				color: #fff;
				font-family: "Consolas", 'Courier New', "Courier", "Monaco", "monospace";
				font-size: calc(var(--editor-font-size) * 0.9);
				padding: 10px 12px;
				border-radius: 3px;
				grid-template-columns: max-content 16px max-content;
			}

			#message[state="hidden"] {
				z-index: -4;
			}

			#message[state="active"] {
				z-index: 4;
			}

			#message[type="error"] {
				background-color: #500;
				outline: 1px solid #f44;
			}

			#message > .button {
				color: #bbb;
				font-size: calc(var(--editor-font-size) * 0.8);
			}

			#message > .button:hover {
				color: #fff;
			}

		</style>

	</head>

	<body class="grid" id="body">

		<!-- editor style -->

		<style id="settings">

			* {
				--editor-font-family:				"Consolas", 'Courier New', "Courier", "Monaco", "monospace";
				--editor-font-size:					14px;
				--editor-tab-size:					4;
				--editor-line-height: 				16px;

				--editor-footer-color:				#dde;

				--editor-color:						#fff;
				--editor-background-color:			#222326;

				--editor-line-background-color:		#27282a;
				--editor-line-color:				#fff;
				--editor-line-color-inactive:		#aab;

				--editor-caret-style:				1px solid #fff;

				--editor-focus-outline:				none;

				--editor-lineNumber-width:			36px;

				--editor-scrollBar-activeWidth:		16px;
				--editor-scrollBar-minimalWidth:	4px;
			}

		</style>

		<div id="wrapper">

			<textarea id="input" wrap="off"></textarea>

			<div class="grid" id="editorGrid">

				<pre id="editorLine"></pre>

				<pre id="editorSurface"><span id="caret" blink="on"></span></pre>

			</div>

			<div id="scrollTopBar"></div>

			<div class="contextmenu" id="contextmenu" state="hidden"></div>

			<div class="grid" id="message" state="hidden"><span></span><span></span><span class="button" id="closeMessage">CLOSE</span></div>

		</div>

		<div class="grid" id="footer">
			<div class="left"><span>insertion</span></div>
			<div></div>
			<div class="right"><span>tab: 4</span><span>HTML</span></div>
		</div>

		<script type="text/javascript">

			"use strict";

			{

				fetch("./buffermachine/target/wasm32-unknown-unknown/release/buffermachine.wasm")
				.then(response => response.arrayBuffer())
				.then(bytes => WebAssembly.instantiate(bytes, {}))
				.then(results => {console.log(results.instance.exports.add(1, 2))})

				const ARAVE = {

					// ARAVE.Instance : text buffer

					Instance: class {

						#buffer; // <- this is a private field

						constructor(init) {
							Object.assign(this, {
								type: init.type,
								file: {
									name: "", handle: null
								},
								pos: 0,
								selection: []
							});
							this.#buffer = {
								original: init.original,
								add: "",
								piece: {
									table: [{
										type: "original",
										from: 0,
										to: init.original.length
									}],
									index: 0,
									max: init.max
								}
							}
						}

						getText(init) {
							let bufferText = "";
							for(let i = 0; i < this.#buffer.piece.index + 1; i++) {
								bufferText += this.#buffer[this.#buffer.piece.table[i].type].slice(
									this.#buffer.piece.table[i].from,
									this.#buffer.piece.table[i].from + this.#buffer.piece.table[i].to
								)
							};
							return bufferText;
						}

						getCaret() {}

						acceptChunk(string) {
							if(this.#buffer.piece.table.length !== (this.#buffer.piece.index + 1)) {
								this.#buffer.piece.table.fill(null, this.#buffer.piece.index, this.#buffer.piece.length);
								this.#buffer.piece.table.filter(Boolean);
							};
							this.#buffer.piece.table.push({
								type: "add",
								from: this.#buffer.add.length,
								to: string.length
							});
							this.#buffer.add += string;
							this.#buffer.piece.index++;
						}

						render(scrollTop, scrollLeft) {
							return "this\n"
						}

						undo() {
							if(0 < this.#buffer.piece.index) this.#buffer.piece.index--;
						}

						redo() {
							if((this.#buffer.piece.index - 1) < this.#buffer.piece.table.length) this.#buffer.piece.index++;
						}

						up() {}

						down() {}

						left() {}

						right() {}

						get availableMimeType() {}
					},

					// ARAVE.Surface : HTML rendering process

					Surface: class {
						constructor(init) {Object.assign(this, {
							instance: init.instance,
							target: init.target
						})}
					},
				};

				const operation = [

					{
						Undo: {
							command: "Ctrl+Z",
							hint: "Undo operation",
							action: "editor.buffer.undo()"
						},
						Redo: {
							command: "Ctrl+Y",
							hint: "Redo operation",
							action: "editor.buffer.redo()"
						},
					},
					{
						Copy: {
							command: "Ctrl+C",
							hint: "Copy selected string to clipboard",
							action: "editor.copy('contextmenu')"
						},
						Cut: {
							command: "Ctrl+X",
							hint: "Cut and paste selected string to clipboard",
							action: "editor.cut('contextmenu')"
						},
						Paste: {
							command: "Ctrl+V",
							hint: "Paste string from clipboard",
							action: "editor.buffer.paste()"
						},
					},
					{
						Save: {
							command: "Ctrl+S",
							hint: "Copy selected string to clipboard",
							action: "editor.save()"
						},
						New: {
							command: "Ctrl+N",
							hint: "Cut and paste selected string to clipboard",
							action: "editor.buffer.flush()"
						},
						Open: {
							command: "Ctrl+O",
							hint: "Paste string from clipboard",
							action: "editor.open()"
						},
					},
					{
						Search: {
							command: "Ctrl+F",
							hint: "Copy selected string to clipboard",
							action: "editor.save()"
						},
						Replace: {
							command: "Ctrl+H",
							hint: "Cut and paste selected string to clipboard",
							action: "editor.buffer.flush()"
						},
					},
					{
						Operate: {
							command: "Ctrl+F",
							hint: "Copy selected string to clipboard",
							action: "test()"
						},
					},
					{
						Settings: {},
						"About Text app": {}
					},
				]

				const surface = new ARAVE.Surface({
					target: document.getElementById("#editor-1"),
				})

				const editor = {

					mode: "insertion",

					buffer: {

						keyProperty: {
							shift: false
						},
						
						input: document.getElementById("input"),

						data: [],

						selection: [
							[100, 130],
							[20, 40],
							[5, 10]
						],

						selectedData: {
							data: [],
							opArea: [Infinity, 0]
						},

						caret: [
							0
						],

						operationCaret: 0,

						gap: undefined,

						clipboardData: "",

						fileName: "",

						fileHandle: null,

						currentControlQueue: [],

						history: {

							queue: {

							},

							stack: [

								{
									type: "insertion",
									from: 0,
									content: "abc"
								},

								{
									type: ""
								}
							],

							pushQueue() {
								this.stack.push(this.queue);
								this.queue = Object.create(null);
							}
						},

						set(value) {
							switch (typeof value) {
								case "string":
									this.data = value;
									break;
								case "number":
									this.data = String(value);
									break;
								case "array":
									this.data = value.join("");
									break;
								default:
									throw new Error("Failed to assign: value type is invalid")
							}
						},

						flush() {

							this.file = {
								name: "",
								handle: null
							}

							this.input.value = "";

							globalThis.editor.interface.refresh();
						},

						undo() {},

						redo() {},

						paste: async () => {
							await navigator.permissions.query({ name: "clipboard-read" }).then(res => {
								switch(res.state) {
									case "granted":
									case "prompt":
										console.log("ok");
										async () => {
											await navigator.clipboard.readText().then(text => this.clipboardData = text);
										};
										break;
									case "denied":
										editor.interface.showMessageProc("error", 'Clipboard access rejected, but Ctrl+V is available.');

								}
							})
						},

						pushHistory(init) {
							this.history.pushQueue();
							this.input.value = "";
						},

						setSelection(from, to) {
						},

						instanceList: Object.create(null),

						operate(init) {
							switch(init.type) {
								case "set":
									for(let i = 0; i < init.from.length; i++) {
										for(let j = 0; j < init.data.length; j++) {
											if(this.data[this.operationCaret] === null) {
												this.data[this.operationCaret] = init.data[j];
												this.operationCaret++;
												this.gap[0]++;
												if(this.gap[0] === this.gap[1]) this.gap = undefined;
											} else if(this.data[this.operationCaret - 1] === null) {
												this.data[this.operationCaret - 1] = init.data[j];
												this.gap[1]--;
												if(this.gap[0] === this.gap[1]) this.gap = undefined;
											} else {
												if(this.gap === undefined) {
													this.data.splice(this.operationCaret, 0, init.data[j], null, null, null, null, null, null, null);
													this.operationCaret++;
													this.gap = [this.operationCaret, this.operationCaret + 7];
												} else {
													let caretBuffer = this.operationCaret - this.gap[1];
													this.data.splice(this.gap[0], this.operationCaret, ...this.data.slice(this.gap[1], this.operationCaret), ...this.data.slice(this.gap[0], this.gap[1]));
													for(let i = 0; i < 2; i++) this.gap[i] += caretBuffer;
													this.data[this.operationCaret - 1] = init.data[j];
													this.gap[1]--;
												}
											};
										}
									}
									break;
								case "get":
									break;
								case "del":
							}
						},

						operateWithPieceTable(init) {
							switch(init.type) {
								case "set":

									break;
							}
						},

						getSelectedData(init) {
							if(!!this.selection.length) {
								let temp = {
									text: [],
									data: [],
									selection: [],
									selectedArea: [Infinity, 0],
								}
								for(const index of this.selection) {
									if(index[0] < temp.selectedArea[0]) temp.selectedArea[0] = index[0];
									if(index[1] > temp.selectedArea[1]) temp.selectedArea[1] = index[1];
								}
								temp.data = this.data.slice(temp.selectedArea[0], temp.selectedArea[1] + 1);
								temp.selection = this.selection.map(index => index.map(selection => selection - temp.selectedArea[0]))
								for(const index of temp.selection) {
									temp.text.push(temp.data.slice(index[0], index[1] + 1).join(""))
								};
								if(init.reduce === true) {
									this.operate({
										type: "del",
										from: temp.selection
									})
								};
								return ((init.type === "string")? temp.text.join("\n") : temp.text)
							}
						},

						renderPipeline() {

						},

						pasteToClipboard(init) {
							switch(init.executedFrom) {
								case "contextmenu":
									navigator.clipboard.writeText(init.text);
									break;
								case "shortcut":
									editor.interface.input.value = init.text;
									setTimeout(() => {
										editor.interface.input.value = "";
									}, 0)
									break;
							}
						},

						dev() {
							
						},

						/* 
							editor.instance.js1 = new editor.buffer.instance({original: "114514"})
							editor.instance.js1.acceptChunk("editor");
						*/
					},

					element: {

						surface: document.getElementById("editorSurface"),
						editorGrid: document.getElementById("editorGrid"),
						editorLine: document.getElementById("editorLine"),
						input: document.getElementById("input"),
						editorCaret: document.getElementById("caret")

					},

					interface: {

						surface: document.getElementById("editorSurface"),

						grid: document.getElementById("editorGrid"),

						line: document.getElementById("editorLine"),

						message: document.getElementById("message"),

						ctx: document.getElementById("contextmenu"),

						caret: {
							blink: true
						},

						keyProperty: {
							shift: false
						},

						contextmenu:{
							showed: false,
							operation: [
								{
									Undo: {
										command: "Ctrl+Z",
										hint: "Undo operation",
										action: "editor.buffer.undo()"
									},
									Redo: {
										command: "Ctrl+Y",
										hint: "Redo operation",
										action: "editor.buffer.redo()"
									},
								},
								{
									Copy: {
										command: "Ctrl+C",
										hint: "Copy selected string to clipboard",
										action: "editor.copy('contextmenu')"
									},
									Cut: {
										command: "Ctrl+X",
										hint: "Cut and paste selected string to clipboard",
										action: "editor.cut('contextmenu')"
									},
									Paste: {
										command: "Ctrl+V",
										hint: "Paste string from clipboard",
										action: "editor.buffer.paste()"
									},
								},
								{
									Save: {
										command: "Ctrl+S",
										hint: "Copy selected string to clipboard",
										action: "editor.save()"
									},
									New: {
										command: "Ctrl+N",
										hint: "Cut and paste selected string to clipboard",
										action: "editor.buffer.flush()"
									},
									Open: {
										command: "Ctrl+O",
										hint: "Paste string from clipboard",
										action: "editor.open()"
									},
								},
								{
									Search: {
										command: "Ctrl+F",
										hint: "Copy selected string to clipboard",
										action: "editor.save()"
									},
									Replace: {
										command: "Ctrl+H",
										hint: "Cut and paste selected string to clipboard",
										action: "editor.buffer.flush()"
									},
								},
								{
									Operate: {
										command: "Ctrl+F",
										hint: "Copy selected string to clipboard",
										action: "test()"
									},
								},
								{
									Settings: {},
									"About Text app": {}
								},
							]
						},

						lineCount: -1,

						minimalDigits: 3,

						previousProperty: {
							x: 0,
							y: 0
						},

						refresh(init) {
							let temp = {
								line: init.data.split("").filter(index => index === "\n"),
								lineDOM: "",
								surfaceDOM: "",
								currentSurfaceLine: document.getElementById("editorSurface").children,
								activeLine: [1],
							};
							temp.lineDigits = temp.line.length.toString().length;
							if(temp.lineDigits < this.minimalDigits) temp.lineDigits = this.minimalDigits;
							for(let i = 1; i <= temp.line.length; i++) {
								temp.lineDOM += (" ".repeat(temp.lineDigits - i.toString().length) + (
									(temp.activeLine.includes(i))? "<span class='active'>" + i + "</span>" : i
								)+ "\n");
							};
							this.line.innerHTML = (temp.lineDOM += "\n".repeat(Math.ceil(document.getElementById("wrapper").clientHeight / 16) - 2));
							// this.surface.innerHTML = 
							this.lineCount = temp.line.length;
						},

						showMessageProc(type, arg) {
							this.message.children[0].textContent = arg.replace(/\n/g, "");
							this.message.setAttribute("type", type);
							this.message.setAttribute("state", "active");
						},

						closeMessageProc() {
							this.message.setAttribute("state", "hidden");
						},

						scrollProc() {
							let temp = {
								top: (!this.keyProperty.shift)? "deltaY" : "deltaX",
								left: (!this.keyProperty.shift)? "deltaX" : "deltaY",
							};
							this.grid.scrollTop += event[temp.top];
							if(this.lineCount === 1) this.grid.scrollTop = 0;
							this.surface.scrollLeft += event[temp.left];
							document.getElementById("scrollTopBar").style.transform = `translateY${(document.getElementById("editorGrid").scrollTop / document.getElementById("editorGrid").scrollHeight)}px`;
						},

						showContextMenuProc() {
							let temp = Object.create(null);
							// calculate and set contextmenu location
							if(event.pageX !== this.previousProperty.x || event.pageY !== this.previousProperty.y) {
								temp.clientRect = this.ctx.getBoundingClientRect();
								this.ctx.style.transform = `translate(${
									event.pageX + 2 - (((event.pageX + temp.clientRect.width) > window.innerWidth)? (temp.clientRect.width + 4) : -4)
								}px,${
									event.pageY + 2 - (((event.pageY + temp.clientRect.height) > window.innerHeight)? (temp.clientRect.height + 4) : -4)
								}px)`;
								this.previousProperty = {
									x: event.pageX,
									y: event.pageY
								};
							};
							// render and place html from configuration
							this.ctx.innerHTML = (() => {
								let html = "";
								for(const group of editor.interface.contextmenu.operation) html += `<div class=\"contextmenu group\">${(() => {
									let component = "";
									for(const index in group) component += `<div class="grid contextmenu index" title="${group[index].hint}" onclick="${group[index].action}"><span class="contextmenu">${index}</span><span class="contextmenu">${((!!group[index].command)? group[index].command : "")}</span></div>`;
									return component;
								})()}</div>`;
								return html.replace(/\t|\n/g, "");
							})();
							this.ctx.setAttribute("state", "active");
							this.contextmenu.showed = true;
						},

						hideContextMenuProc() {
							this.ctx.setAttribute("state", "hidden");
							editor.mode = "insertion";
							editor.interface.contextmenu.showed = false;
						}
					},

					selectionProperty: null,

					previousProperty: {
						inputValueLine: 0,
						page: {
							x: 0,
							y: 0
						}
					},

					// global methods: called by contextmenu or shortcuts

					createInstance(init) {
						if(!!editor.buffer.instance[init.name]) {
							throw new Error("Cannot create new instance: same name instance already exists");
						} else {
							editor.buffer.instance[init.name] = {

							}
						}
					},

					copy(executedFrom) {
						editor.buffer.pasteToClipboard({
							text: editor.buffer.getSelectedData({ type: "string", reduce: false }),
							executedFrom: executedFrom
						})
					},

					cut(executedFrom) {
						editor.buffer.pasteToClipboard({
							text: editor.buffer.getSelectedData({ type: "string", reduce: true }),
							executedFrom: executedFrom
						})
					},

					open: async (readAs) => {

						let temp = Object.create(null);

						[editor.buffer.fileHandle] = await window.showOpenFilePicker(
							{
								types: [
									{
										description: "Text file",
										accept: {
											"text/*": [],
											"application/*": []
										},
									}
								],
								excludeAcceptAllOption: true,
								multiple: false
							}
						);
						temp.result = new FileReader;
						temp.result.readAsText(await editor.buffer.fileHandle.getFile(), "UTF-8");
						temp.result.onload = event => {
							editor.buffer.data = event.target.result
						};

					},

					save: async () => {
						let temp = Object.create(null);
						if(!editor.buffer.fileHandle) editor.buffer.fileHandle = await window.showSaveFilePicker({
							types: [
								{
									description: "Text file",
									accept: {
										"text/*": [],
										"application/*": []
									}
								},
							]
						});
						temp.writable = await editor.buffer.fileHandle.createWritable();
						await temp.writable.write(editor.buffer.data);
						await temp.writable.close();
					},
				};

				window.onload = () => {
					const index = new ARAVE.Instance({
						original: "application",
						type: "text/plain",
						max: 50,
					});

					window.test = () => {
						index.acceptChunk("\napp".repeat(100));
						console.log(index.getText());
						index.undo();
						console.log(index.getText());
					};

					[
						[() => {
							document.getElementById('caret').setAttribute('blink', (editor.interface.caret.blink? "off" : "on"));
							editor.interface.caret.blink = !editor.interface.caret.blink;
						}, 600]

					].forEach(set => setInterval(...set));

					[
						[
							"beforeunload", event => {
								event.preventDefault();
								event.returnValue = "";
							}, { passive: false }
						],

						[
							"wheel", event => {
								event.preventDefault();
							}, { passive: false }
						],

						// key event

						[
							"keydown", event => {
								let temp = {
									input: document.getElementById("input")
								};
								if(event.ctrlKey) {
									switch(event.key) {
										case "v":
											editor.buffer.pushHistory();
											setTimeout(() => {
												console.log(document.getElementById("input").value);
												if(!(temp.input.value.length === 0)) {
													editor.buffer.pushHistory();
												}
											}, 0);
											break;
										case "x":
										case "c":
											editor.buffer.pushHistory();
											temp.input.value = editor.buffer.getSelectedData().value;
											temp.input.select();
											setTimeout(() => {
												if(event.key === "x") {
													console.log("x")
													editor.buffer.pushHistory({
														action: "remove",
														value: temp.input.value
													});
												};
											}, 0);
									}
								} else {
									temp.caretClientRect = document.getElementById("caret").getBoundingClientRect();
									document.getElementById("input").style.transform = `translate(${(temp.caretClientRect.x + 2)}px,${(temp.caretClientRect.y + 2)}"px)`;
									editor.buffer.keyProperty.shift = event.shiftKey;
									switch(event.key) {
										case "Enter":
											editor.buffer.pushHistory();
											editor.interface.refresh(editor.buffer);
											break;
									};
								};
							}, { passive: false }
						],

						// mouse event

						[
							"pointerdown", event => {
								// contextmenu appearance control process
								if(!event.target.classList.contains("contextmenu")) {
									if(editor.interface.contextmenu.showed) {
										editor.interface.hideContextMenuProc();
									} else if(event.button === 2) {
										editor.interface.showContextMenuProc();
										editor.mode = "contextmenu";
									};
								} else {
								}
								switch(event.target.id) {
									case "closeMessage":
										editor.interface.closeMessageProc();
										break;
								};
							}
						],

						[
							"pointerup", event => {
								console.log(event.target.textContent)
								if(event.target.classList.contains("contextmenu")) {
									editor.interface.hideContextMenuProc();
								} else {
									document.getElementById("input").focus();
								}
							}, { passive: true }
						],

						[
							"contextmenu", event => event.preventDefault(), { passive: false }
						]

					].forEach(index => window.addEventListener(...index));

					for(const instance in editor.timeoutProcess) editor.timeoutProcess[instance]();

					// editor.interface.refresh(editor.buffer);

					document.getElementById("input").focus();

				}
			}
		</script>

	</body>

</html>