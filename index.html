<!--

	Text v0.0.1

	created and maintained by https://ihasq.com

	editor style settings are modifiable at /html/body/style

-->

<!DOCTYPE html>

<html>

	<head>

		<title>Text (unsaved)</title>

		<meta charset="utf-8"/>

		<style>

			* {
				box-sizing: border-box;
			}

			.grid {
				display: grid;
			}


			html {
				height: 100vh;
				width: 100vw;
			}

			html, body {
				overflow: hidden;
			}

			body, div#wrapper, #editorGrid {
				height: 100%;
				width: 100%;
			}

			html, body, div#wrapper, #editorGrid, #editorLine {
				padding: 0px;
				margin: 0px;
				user-select: none;
			}

			body {
				grid-template-rows: auto calc(var(--editor-font-size) + 8px);
			}

			div#wrapper {
				position: relative;
			}

			div#wrapper > * {
				position: absolute;
			}

			#editorGrid {
				z-index: 0;
				grid-template-columns: var(--editor-lineNumber-width) auto;
				width: 100%;
				height: 100%;
				overflow: hidden;
			}

			#editorLine {
				font-family: var(--editor-font-family);
				font-size: var(--editor-font-size);
				tab-size: var(--editor-tab-size);
				line-height: var(--editor-line-height);

				color: var(--editor-line-color-inactive);
				background-color: var(--editor-line-background-color);

				margin: 0px;
				padding: 6px;
			}

			#editorSurface {
				font-family: var(--editor-font-family);
				font-size: var(--editor-font-size);
				tab-size: var(--editor-tab-size);
				line-height: var(--editor-line-height);

				background-color: var(--editor-background-color);
				color: var(--editor-color);

				overflow: hidden;

				height: max-content;
				min-height: 100%;

				margin: 0px;
				padding: 6px 10px;

				cursor: text;

				user-select: auto;
			}

			#editorSurface:focus {
				outline: var(--editor-focus-outline);
			}

			#scrollTopBar {
				z-index: 2;
				right: 0;
				width: 4px;
				height: 50%;
				background-color: #555;
				opacity: 70%;
				border-radius: 2px;
			}

			#editorSurface::after {
				content: " ";
			}

			span#caret[blink="on"] {
				outline: var(--editor-caret-style);
			}

			span#caret[blink="off"] {
				outline: none;
			}

			textarea#input {
				z-index: 1;
				opacity: 0;
				height: 4px;
				width: 1px;
				resize: none;
				user-select: none;
				border: none;
				padding: 0px;
			}

			div#footer {
				background-color: #292929;
				color: var(--editor-footer-color);

				font-family: var(--editor-font-family);
				font-size: calc(var(--editor-font-size) * 0.9);

				border-top: 1px solid #555;

				width: 100%;
				grid-template-columns: 200px auto 400px;
				overflow: hidden;
			}

			div#footer > div {
				width: auto;
				margin: auto 6px;
			}

			div#footer > div.left > span {
				margin-left: 4px;
			}

			div#footer > div.right {
				text-align: end;
			}

			div#footer > div.right > span {
				text-align: end;
				margin-right: 4px;
			}

			pre#editorLine > span.active {
				color: var(--editor-line-color);
			}

			#contextmenu {
				width: 220px;
				height: max-content;
				background-color: #222;
				outline: 1px solid #555;
				border-radius: 3px;
				overflow: hidden;
			}

			#contextmenu[state="active"] {
				z-index: 3;
			}

			#contextmenu[state="hidden"] {
				z-index: -1;
			}

			#contextmenu > div.group {
				border-bottom: 1px solid #555;
			}

			#contextmenu > div.group:last-child {
				border-bottom: none;
			}

			#contextmenu > div.group > div.index {
				grid-template-columns: auto 60px;
				font-size: 13px;
				font-family: var(--editor-font-family);
				color: #bbb;
				padding: 5px 18px;
				background-color: transparent;
			}

			#contextmenu > div.group > div.index.disabled {
				color: #666;
			}

			#contextmenu > div.group > div.index > span:last-child {
				color: #999;
				text-align: end;
				font-size: calc(var(--editor-font-size) * 0.8);
			}

			#contextmenu > div.group > div.index:hover:not(.disabled) {
				background-color: #363636;
				color: #fff;
			}

			#contextmenu > div.group > div.index:first-child {
				padding-top: 7px;
			}

			#message {
				height: max-content;
				width: max-content;
				inset: calc(100% - 48px) 16px 0 auto;
				background-color: #222;
				outline: 1px solid #555;
				color: #fff;
				font-family: "Consolas", 'Courier New', "Courier", "Monaco", "monospace";
				font-size: calc(var(--editor-font-size) * 0.9);
				padding: 10px 12px;
				border-radius: 3px;
				grid-template-columns: max-content 16px max-content;
			}

			#message[state="hidden"] {
				z-index: -4;
			}

			#message[state="active"] {
				z-index: 4;
			}

			#message[type="error"] {
				background-color: #500;
				outline: 1px solid #f44;
			}

			#message > .button {
				color: #bbb;
				font-size: calc(var(--editor-font-size) * 0.8);
			}

			#message > .button:hover {
				background-color: #363636;
				color: #fff;
			}

		</style>

	</head>

	<body class="grid" id="body">

		<!-- editor style -->

		<style id="settings">

			* {
				--editor-font-family:				"Consolas", 'Courier New', "Courier", "Monaco", "monospace";
				--editor-font-size:					14px;
				--editor-tab-size:					4;
				--editor-line-height: 				16px;

				--editor-footer-color:				#dde;

				--editor-color:						#fff;
				--editor-background-color:			#222;

				--editor-line-background-color:		#333;
				--editor-line-color:				#fff;
				--editor-line-color-inactive:		#aab;

				--editor-caret-style:				1px solid #fff;

				--editor-focus-outline:				none;

				--editor-lineNumber-width:			40px;

				--editor-scrollBar-activeWidth:		16px;
				--editor-scrollBar-minimalWidth:	4px;
			}

		</style>

		<div id="wrapper">

			<textarea id="input" wrap="off"></textarea>

			<div class="grid" id="editorGrid">

				<pre id="editorLine"></pre>

				<pre id="editorSurface"><span id="caret" blink="on"></span></pre>

			</div>

			<div id="scrollTopBar"></div>

			<div class="contextmenu" id="contextmenu" state="hidden"></div>

			<div class="grid" id="message" state="hidden"><span></span><span></span><span class="button" id="closeMessage">CLOSE</span></div>

		</div>

		<div class="grid" id="footer">
			<div class="left"><span>insertion</span></div>
			<div></div>
			<div class="right"><span>tab: 4</span><span>HTML</span></div>
		</div>

		<script type="text/javascript">

			"use strict";

			{

				window.editor = {

					mode: "insertion",

					buffer: {

						isExecCommandEnabled: true,

						keyProperty: {
							shift: false
						},
						
						input: document.getElementById("input"),

						data: "SLAM\nDUNK\nMOVIE",

						selection: [
							[0, 6]
						],

						clipboardData: "COPIED",

						fileName: "",

						fileHandle: null,

						currentControlQueue: [],

						history: {

							queue: {

							},

							stack: [

								{
									type: "insertion",
									from: 0,
									content: "abc"
								},

								{
									type: ""
								}
							],

							pushQueue() {
								this.stack.push(this.queue);
								this.queue = Object.create(null);
							}
						},

						open: async (readAs) => {

							let temp = Object.create(null);

							[this.fileHandle] = await window.showOpenFilePicker(
								{
									types: [
										{
											description: "Text file",
											accept: {
												"text/*": [],
												"application/*": []
											},
										}
									],
									excludeAcceptAllOption: true,
									multiple: false
								}
							);
							temp.result = new FileReader;
							temp.result.readAsText(await this.fileHandle.getFile(), "UTF-8");
							temp.result.onload = event => {
								this.input.value = event.target.result;
								globalThis.editor.action.refresh();
							}

						},

						save: async () => {
							let temp = Object.create(null);
							if(!this.fileHandle) this.fileHandle = await window.showSaveFilePicker({
								types: [
									{
										description: "Text file",
										accept: {
											"text/*": [],
											"application/*": []
										}
									},
								]
							});
							temp.writable = await this.fileHandle.createWritable();
							await temp.writable.write(this.data);
							await temp.writable.close();
						},

						flush() {

							this.file = {
								name: "",
								handle: null
							}

							this.input.value = "";

							globalThis.editor.interface.refresh();
						},

						undo() {},

						redo() {},

						copy() {
							navigator.clipboard.writeText(this.clipboardData);
						},

						cut() {
							navigator.clipboard.writeText(this.clipboardData);
						},

						paste: async () => {
							await navigator.permissions.query({ name: "clipboard-read" }).then(res => {
								switch(res.state) {
									case "granted":
									case "prompt":
										console.log("ok");
										async () => {
											await navigator.clipboard.readText().then(text => this.clipboardData = text);
										};
										break;
									case "denied":
										editor.interface.showMessageProc("error", 'Clipboard access denied, but Ctrl+V is available.');

								}
							})
							
						},

						pushHistory(init) {
							this.history.pushQueue();
							this.input.value = "";
						},

						getSelectedData() {
							let returnArray = [];
							for(const index of this.selection) {
								returnArray.push({
									value: this.data.substring(...index),
									from: index[0],
									to: index[1]
								})
							};
							return returnArray;
						},
					},

					element: {

						surface: document.getElementById("editorSurface"),
						editorGrid: document.getElementById("editorGrid"),
						editorLine: document.getElementById("editorLine"),
						input: document.getElementById("input"),
						editorCaret: document.getElementById("caret")

					},

					interface: {

						surface: document.getElementById("editorSurface"),

						line: document.getElementById("editorLine"),

						message: document.getElementById("message"),

						ctx: document.getElementById("contextmenu"),

						caret: {
							blink: true
						},

						keyProperty: {
							shift: false
						},

						contextmenu:{
							showed: false,
							operation: [
								[
									["Undo", {
										command: "Ctrl+Z",
										hint: "Undo operation",
										action: "editor.buffer.undo()"
									}],
									["Redo", {
										command: "Ctrl+Y",
										hint: "Redo operation"
									}],
								],
								[
									["Copy", {
										command: "Ctrl+C",
										hint: "Copy selected string to clipboard",
										action: "editor.buffer.copy()"
									}],
									["Cut", {
										command: "Ctrl+X",
										hint: "Cut and paste selected string to clipboard"
									}],
									["Paste", {
										command: "Ctrl+V",
										hint: "Paste string from clipboard",
										action: "editor.buffer.paste()"
									}],
								],
								[
									["Save", {
										command: "Ctrl+S",
										hint: "Copy selected string to clipboard"
									}],
									["New", {
										command: "Ctrl+N",
										hint: "Cut and paste selected string to clipboard"
									}],
									["Open", {
										command: "Ctrl+O",
										hint: "Paste string from clipboard"
									}],
								],
								[
									["Settings", {}],
									["About Text app", {}]
								],
							]
						},

						lineCount: -1,

						minimalDigits: 3,

						refresh(init) {
							let temp = {
								line: init.data.split(/\n/g),
								lineDOM: "",
								surfaceDOM: "",
								currentSurfaceLine: document.getElementById("editorSurface").children,
								activeLine: [1],
							};
							// for(let i = 0; i < temp.line.length; i++) {
							// 	if(temp.currentSurfaceLine[i].textContent !== temp.line[i]) {
							// 		temp.currentSurfaceLine[i].textContent = temp.line[i]
							// 	}
							// }
							temp.lineDigits = temp.line.length.toString().length;
							if(temp.lineDigits < this.minimalDigits) temp.lineDigits = this.minimalDigits;
							for(let i = 1; i <= temp.line.length; i++) {
								temp.lineDOM += (" ".repeat(temp.lineDigits - i.toString().length) + (
									(temp.activeLine.includes(i))? "<span class='active'>" + i + "</span>" : i
								)+ "\n");
							};
							this.line.innerHTML = (temp.lineDOM += "\n".repeat(Math.ceil(document.getElementById("wrapper").clientHeight / 16) - 2));
							// this.surface.innerHTML = 
							this.lineCount = temp.line.length;
						},

						showMessageProc(type, arg) {
							this.message.children[0].textContent = arg.replace(/\n/g, "");
							this.message.setAttribute("type", type);
							this.message.setAttribute("state", "active");
						},

						closeMessageProc() {
							this.message.setAttribute("state", "hidden");
						},

						scrollProc() {
							let temp = {
								top: (!this.keyProperty.shift)? "deltaY" : "deltaX",
								left: (!this.keyProperty.shift)? "deltaX" : "deltaY",
							};
							document.getElementById("editorGrid").scrollTop += event[temp.top];
							document.getElementById("editorSurface").scrollLeft += event[temp.left];
							document.getElementById("scrollTopBar").style.transform = `translateY${(document.getElementById("editorGrid").scrollTop / document.getElementById("editorGrid").scrollHeight)}px`;
						},

						showContextMenuProc() {
							let temp = Object.create(null);
							if(event.pageX !== editor.previousProperty.page.x || event.pageY !== editor.previousProperty.page.y) {
								temp.clientRect = this.ctx.getBoundingClientRect();
								this.ctx.style.transform = `translate(${
									event.pageX + 2 - (((event.pageX + temp.clientRect.width) > window.innerWidth)? (temp.clientRect.width + 4) : -4)
								}px,${
									event.pageY + 2 - (((event.pageY + temp.clientRect.height) > window.innerHeight)? (temp.clientRect.height + 4) : -4)
								}px)`;
								editor.previousProperty.page = {
									x: event.pageX,
									y: event.pageY
								};
							};
							this.ctx.innerHTML = (() => {
								let html = "";
								for(const group of editor.interface.contextmenu.operation) html += `
									<div class=\"contextmenu group\">${(() => {
										let component = "";
										for(const index of group) component += `
											<div class="grid contextmenu index"${((!!index[1].hint)? ("title=\"" + index[1].hint + "\"") : "")}>
												<span class="contextmenu">${index[0]}</span><span class="contextmenu">${((!!index[1].command)? index[1].command : "")}</span>
											</div>
										`;
										return component;
									})()}</div>
								`;
								return html.replace(/\t|\n/g, "");
							})();
							editor.mode = "contextmenu";
							this.ctx.setAttribute("state", "active");
							editor.interface.contextmenu.showed = true;
						},

						hideContextMenuProc() {
							this.ctx.setAttribute("state", "hidden");
							editor.mode = "insertion";
							editor.interface.contextmenu.showed = false;
						}
					},

					editorProperty: {

						editorLine: 0,
						focusLine: 1,
						currentBufferId: -1,
						minimalDigits: 3

					},

					selectionProperty: null,

					previousProperty: {
						inputValueLine: 0,
						page: {
							x: 0,
							y: 0
						}
					},
				}

				window.onload = () => {

					[
						[() => {
							document.getElementById('caret').setAttribute('blink', (editor.interface.caret.blink? "off" : "on"));
							editor.interface.caret.blink = !editor.interface.caret.blink;
						}, 600],

					].forEach(set => setInterval(...set));

					[
						[
							"beforeunload", event => {
								event.preventDefault();
								event.returnValue = "";
							}, { passive: false }
						],

						[
							"wheel", event => {
								event.preventDefault();
								editor.interface.scrollProc(event);
							}, { passive: false }
						],

						// key event

						[
							"keydown", event => {
								let temp = {
									input: document.getElementById("input")
								};
								if(event.ctrlKey) {
									switch(event.key) {
										case "v":
											editor.buffer.pushHistory();
											setTimeout(() => {
												console.log(document.getElementById("input").value);
												if(!(temp.input.value.length === 0)) {
													editor.buffer.pushHistory();
												}
											}, 0);
											break;
										case "x":
										case "c":
											editor.buffer.pushHistory();
											temp.input.value = editor.buffer.getSelectedData().value;
											temp.input.select();
											setTimeout(() => {
												if(event.key === "x") {
													console.log("x")
													editor.buffer.pushHistory({
														action: "remove",
														value: temp.input.value
													});
												};
											}, 0);
									}
								} else {
									temp.caretClientRect = document.getElementById("caret").getBoundingClientRect();
									document.getElementById("input").style.transform = `translate(${(temp.caretClientRect.x + 2)}px,${(temp.caretClientRect.y + 2)}"px)`;
									editor.buffer.keyProperty.shift = event.shiftKey;
									switch(event.key) {
										case "Enter":
											editor.buffer.pushHistory();
											editor.interface.refresh(editor.buffer);
									};
								};
							}, { passive: false }
						],

						// mouse event

						[
							"mousedown", event => {
								// contextmenu appearance control process
								if(!event.target.classList.contains("contextmenu")) {
									if(editor.interface.contextmenu.showed) {
										editor.interface.hideContextMenuProc();
									} else if(event.button === 2) {
										editor.interface.showContextMenuProc();
									};
								};
								switch(event.target.id) {
									case "closeMessage":
										editor.interface.closeMessageProc();
									break;
								};
							}
						],

						[
							"mouseup", event => {
								console.log(event.target.textContent)
								if(event.target.classList.contains("contextmenu")) {
									if(event.target.textContent === "Copy") {
									}
								} else {
									document.getElementById("input").focus();
								}
							}, { passive: true }
						],

						[
							"contextmenu", event => event.preventDefault(), { passive: false }
						]

					].forEach(index => window.addEventListener(...index));

					for(const instance in editor.timeoutProcess) editor.timeoutProcess[instance]();

					editor.interface.refresh(editor.buffer);

					document.getElementById("input").focus();

				}
			}

		</script>

	</body>

</html>